
// EnforceAgentBitcoinTransfer ensures when bitcoin is included in an agent request containing an 
// atomic swap of bitcoin for tokens that it is not in custody of the agent.
// 
// Note: This requires SIG_HASH_SINGLE when being spent by the agent, or only one output in the 
// tx, so that the output hash in the preimage matches the hash of the specified output.
contract EnforceAgentBitcoinTransfer {
    Ripemd160 agentKeyHash; // Hash of public key for agent to authorize transfer.
    Sha256 approveOutputHash; // Hash of output to approve transfer.
    Sha256 refundOutputHash; // Hash of output to deny transfer.

    Ripemd160 expirationKeyHash; // Hash of public key for expiration spend if time lock expire. 
    int expiration; // Block height after which the expiration key can reclaim bitcoin.

    // constructor
    constructor(Ripemd160 agentKeyHash, Sha256 approveOutputHash, Sha256 refundOutputHash, Ripemd160 expirationKeyHash, int expiration) {
        this.agentKeyHash = agentKeyHash;
        this.approveOutputHash = approveOutputHash;
        this.refundOutputHash = refundOutputHash;
        this.expirationKeyHash = expirationKeyHash;
        this.expiration = expiration;
    }

    /*
    * approve approves the bitcoin transfer.
    * preimage is the sig hash preimage for the current input and transaction.
    * 
    * NOTE: This must be called with SIGHASH_SINGLE so that the outputs hash in the preimage is for
    * only the one corresponding output that is hashed in this script.
    */
    public function approve(Sig sig, PubKey pubKey, SigHashPreimage preimage) {
        // Verify agent key.
        require(hash160(pubKey) == this.agentKeyHash);

        // Verify valid signature.
        require(checkSig(sig, pubKey));

        // Verify output hash is correct for approval.
        require(this.approveOutputHash == getOutputsHash(preimage));

        // Verify preimage is correct.
        require(Tx.checkPreimageOpt(preimage));
    }

    /*
    * refund refunds the bitcoin.
    * preimage is the sig hash preimage for the current input and transaction.
    * 
    * NOTE: This must be called with SIGHASH_SINGLE so that the outputs hash in the preimage is for
    * only the one corresponding output that is hashed in this script.
    */
    public function refund(Sig sig, PubKey pubKey, SigHashPreimage preimage) {
        // Verify agent key.
        require(hash160(pubKey) == this.agentKeyHash);

        // Verify valid signature.
        require(checkSig(sig, pubKey));

        // Verify output hash is correct for refund.
        require(this.refundOutputHash == getOutputsHash(preimage));

        // Verify preimage is correct.
        require(Tx.checkPreimageOpt(preimage));
    }

    /*
    * expire allows the sender to reclaim the bitcoin after expiration of the contract.
    * sequence is the 32 bit little endian sequence values that apply to the sig hash preimage.
    * preimage is the sig hash preimage for the current input and transaction.
    *
    * NOTE: This must be called with a SIGHASH_ALL signature so that the sequences hash in the 
    * preimage isn't zeroed out.
    */
    public function expire(Sig sig, PubKey pubKey, bytes sequences, SigHashPreimage preimage) {
        // Verify expire key.
        require(hash160(pubKey) == this.expirationKeyHash);

        // Verify valid signature.
        require(checkSig(sig, pubKey));

        // Verify lock time.
        require(getLockTime(preimage) >= this.expiration);

        // Verify sequence hash matches preimage.
        require(hash256(sequences) == getSequencesHash(preimage));

        // Verify at least one sequence is not MAX so the lock time is actually applied.
        bool allMax = true;
        int offset = 0;
        const bytes max = b'ffffffff';
        loop (5) {
            if (offset < len(sequences) && sequences[offset:offset+4] != max) {
                allMax = false;
            }
            offset+=4;
        }
        require(!allMax);

        // Verify sig hash type is SIG_HASH_ALL or else sequence hash will have been zeroed out
        // in the preimage and the check above would not actually be checking anything.
        require(0x41 == getSigHashType(preimage));

        // Verify preimage is correct.
        require(Tx.checkPreimageOpt(preimage));
    }

    // getSequencesHash parses the hash of the input's sequences from the preimage.
    static function getSequencesHash(SigHashPreimage preimage) : bytes {
        return preimage[36 : 68];
    }

    // getLockTime parses the lock time from the preimage data.
    static function getLockTime(SigHashPreimage preimage) : int {
        int l = len(preimage);
        return unpack(preimage[l - 8 : l - 4]);
    }

    // getOutputsHash parses the hash of the outputs from the preimage.
    static function getOutputsHash(SigHashPreimage preimage) : bytes {
        int l = len(preimage);
        return preimage[l - 40 : l - 8];
    }

    static function getSigHashType(SigHashPreimage preimage) : int {
        int l = len(preimage);
        return unpack(preimage[l - 4 : l]);
    }
}